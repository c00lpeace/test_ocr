# OCR 텍스트 정제 및 매핑

**User:** 이지용 (freshntoxic@gmail.com)  
**Created:** 2/10/2026 9:51:09  
**Updated:** 2/11/2026 17:44:19  
**Exported:** 2/11/2026 17:56:17  
**Link:** [https://chatgpt.com/g/g-p-698a7f61b140819183a2a82faf5ab1e0/c/698a80f8-cfc8-8321-94c6-913ff0f435ea](https://chatgpt.com/g/g-p-698a7f61b140819183a2a82faf5ab1e0/c/698a80f8-cfc8-8321-94c6-913ff0f435ea)  

## Response:
좋아 👍  
이제 진짜 **프로덕션 레벨 설계**로 들어가는 질문이야.

상황 정리하면:

*   상세페이지 전체 이미지가 들어옴
*   어느 구간(상단/중단/하단)인지 모름
*   세로 길이 제각각
*   너무 길면 분할해야 함
*   그런데 분할하면 JSON 결과가 여러 개 생김
*   👉 이걸 어떻게 하나의 최종 JSON으로 합치느냐?

여기서 핵심은:

> 🔥 “분할 결과를 독립 JSON으로 취급하지 말고  
> 부분 정보 조각(fragment)으로 취급해야 한다”

* * *

✅ 정답 구조: “부분 추출 → 병합 전용 단계”
===========================

전체 파이프라인은 이렇게 가는 게 가장 안정적임:

```
1. 원본 이미지
2. 세로 기준 분할 (n개)
3. 각 분할 이미지 → VL 추출 (부분 JSON)
4. 부분 JSON들 병합 단계
5. 최종 단일 JSON 생성
```

* * *

🔥 핵심 아이디어
==========

각 분할 결과는 **완성된 상품 JSON이 아니라**

> “이 이미지 구간에서 발견된 정보” 라고 생각해야 함

* * *

1️⃣ 분할 이미지용 프롬프트 수정
===================

분할 처리할 때는 이렇게 바꾸는 게 좋아:

```
이 이미지는 상품 상세페이지의 일부 구간일 수 있다.
이 구간에서 확인 가능한 상품 정보만 추출하라.
확인되지 않는 정보는 null로 설정하라.
```

이 문장 반드시 필요.

왜냐하면:

*   상단에는 상품명만 있을 수 있음
*   하단에는 소재표만 있을 수 있음
*   중단에는 설명만 있을 수 있음

* * *

2️⃣ 분할 결과 예시
============

### 🔹 상단 이미지 결과

```json
{
  "product_name": "프리미엄 코튼 오버핏 셔츠",
  "brand": "OOO",
  "category": null,
  "material": null,
  "origin_country": null,
  "color": null,
  "size": null,
  "description": null
}
```

### 🔹 중단 이미지 결과

```json
{
  "product_name": null,
  "brand": null,
  "category": null,
  "material": "면 100%",
  "origin_country": "대한민국",
  "color": ["화이트", "블랙"],
  "size": ["M", "L"],
  "description": null
}
```

### 🔹 하단 이미지 결과

```json
{
  "product_name": null,
  "brand": null,
  "category": null,
  "material": null,
  "origin_country": null,
  "color": null,
  "size": null,
  "description": "오버핏 실루엣의 데일리 셔츠"
}
```

* * *

3️⃣ 병합 전략 (가장 중요)
=================

이제 병합 로직.

🎯 병합 기본 원칙
-----------

1.  null이 아닌 값 우선
2.  배열은 합집합
3.  문자열 충돌 시 더 구체적인 것 선택
4.  product\_name은 가장 긴 문자열 우선
5.  brand는 중복 등장 시 동일 여부 체크

* * *

✅ 병합 알고리즘 예시
------------

### 1️⃣ product\_name

*   null 아닌 값들 수집
*   가장 긴 문자열 선택
*   또는 가장 위쪽 이미지 결과 우선

* * *

### 2️⃣ brand

*   null 아닌 값 중 유일값 선택
*   여러 개면 → 재검증 단계

* * *

### 3️⃣ material / origin

*   null 아닌 첫 등장 값 사용
*   충돌 시 더 상세한 표현 선택
    *   "면" vs "면 100%" → 후자 선택

* * *

### 4️⃣ color / size

*   배열 합집합
*   중복 제거

* * *

### 5️⃣ description

*   여러 개면 합치되
*   300자 초과 시 요약

* * *

4️⃣ 병합 방식 2가지 선택지
=================

🔥 방법 A — 코드 병합 (추천 ⭐⭐⭐⭐⭐)
--------------------------

Python 등으로 직접 merge.

장점:

*   비용 없음
*   안정성 높음
*   재현성 좋음

* * *

🔥 방법 B — LLM 병합
----------------

모든 부분 JSON을 다시 LLM에 넣고:

```
아래는 동일 상품의 여러 구간에서 추출된 정보다.
이를 하나의 완전한 JSON으로 통합하라.
```

장점:

*   충돌 판단 자연스러움  
    단점:
*   비용 증가
*   hallucination 위험 증가

👉 대규모 운영이면 코드 병합 추천.

* * *

5️⃣ 이미지 분할 기준
=============

세로 긴 이미지일 경우:

### 추천 기준

*   높이 1500~2000px 단위 분할
*   20~30% 겹치게 분할

왜 겹치냐?

상품명/소재표가 경계에 걸릴 수 있음.

* * *

6️⃣ 고급 안정 전략
============

분할 순서도 중요함.

```
상단 → 중단 → 하단
```

그리고 병합 시:

*   상단 정보 우선
*   하단 정보는 보조

* * *

7️⃣ 최종 권장 아키텍처
==============

```
if image_height < threshold:
    1회 처리
else:
    분할
    각 분할 VL 처리
    코드 병합
```

* * *

🔥 이 구조의 장점
===========

*   4096 토큰 안전
*   긴 이미지 대응 가능
*   정보 누락 최소화
*   hallucination 감소
*   확장성 좋음

* * *

🎯 다음 단계
========

이제 더 깊이 들어갈 수 있음:

1️⃣ 실제 병합 코드 설계  
2️⃣ 충돌 해결 로직 세부 규칙 정의  
3️⃣ 이미지 분할 최적 높이 계산  
4️⃣ 카테고리별 병합 전략 차별화  
5️⃣ 완전 자동화 파이프라인 설계도

어디까지 시스템 설계로 가볼까?

## Response:
좋아. 그럼 **(1) 병합 코드 설계 → (2) 충돌 해결 규칙 → (3) 분할 높이/겹침 최적화 → (4) 카테고리별 병합 차별화 → (5) 완전 자동화 파이프라인**까지 한 번에 “운영 가능한 수준”으로 쭉 정리할게.

* * *

1) 병합 코드 설계 (LLM 없이, 결정적/재현 가능하게)
---------------------------------

### 입력

*   분할 이미지별 VL 출력 JSON들: `parts = [json1, json2, ...]`

### 출력

*   최종 단일 JSON: `final`

### 핵심 아이디어

*   각 분할 결과는 “완성본”이 아니라 **조각 정보(fragment)**.
*   병합은 **규칙 기반**으로 “null 아닌 값 채우기 + 충돌 해결”로 간다.

### 병합 기본 뼈대 (의사코드)

```pseudo
final = empty schema (all null)
evidence = field별로 어떤 part에서 왔는지 추적(옵션)

for field in schema_fields:
  values = [part[field] for part in parts if part[field] not null/empty]

  if values empty: final[field] = null
  else if field is array: final[field] = union(values) with normalization
  else: final[field] = resolve_conflict(field, values, parts_meta)
```

여기서 중요한 건 `parts_meta`:

*   part의 순서(위→아래)
*   해당 part의 “노이즈 구간 여부” (하단 정책/배송 영역일 확률 높음)
*   confidence(선택사항: 모델이 제공하면)

> 실무 팁: **part index 자체가 강력한 신호**야. (보통 상단=상품명/브랜드, 중단=스펙, 하단=정책/고시/배송)

* * *

2) 충돌 해결 로직 세부 규칙 (field별 룰)
----------------------------

아래 룰은 “텍스트 덩어리 OCR” 환경에서 특히 안정적으로 먹혀.

### 공통: 값 정규화(normalization)

*   공백 정리, 특수문자 통일(“,” “/” 등)
*   단위 통일(예: `cm`, `mm`, `g`, `kg`)
*   한글/영문 혼용 정리(예: “White”→“화이트”는 선택사항: 운영 정책에 따라)

* * *

### (A) product\_name

**우선순위**

1.  상단 part에서 나온 값 우선
2.  여러 개면 **가장 긴 값(정보량 많음)**
3.  “상품명”처럼 라벨만 있거나, “상세설명” 같은 값은 제거

**추가 룰**

*   옵션명(색상/사이즈)이 붙은 “상품명+옵션” 형태면 옵션 부분은 분리(가능하면)

* * *

### (B) brand

**우선순위**

1.  “브랜드”/“Brand” 라벨 근처에서 나온 값(모델이 이렇게 뽑아주면 베스트)
2.  상단 part에서 나온 값
3.  충돌(서로 다른 브랜드 2개 이상) 발생 시:
    *   **final.brand = null** 로 두고, “검증 필요” 플래그를 남기는 게 안전

> 브랜드는 hallucination 비용이 가장 큰 필드라, 충돌 시 보수적으로 null 처리 추천.

* * *

### (C) category

*   이미지에서 카테고리가 명시되지 않는 경우가 많아서, 충돌/불확실이면 null이 더 안전
*   만약 운영에서 꼭 필요하면 “별도 카테고리 분류 모델(텍스트 기반)”로 분리하는 게 정확도 좋음

* * *

### (D) material / origin\_country

*   값 충돌 시 **더 구체적인 표현 선택**
    *   “면” vs “면 100%” → “면 100%”
    *   “대한민국” vs “한국” → 표준화해서 “대한민국”
*   여러 소재가 존재하면(혼방):
    *   “면 60%, 폴리 40%” 같은 형식은 그대로 유지하거나,
    *   운영 스키마가 있으면 구조화(소재 배열)로 확장

* * *

### (E) color / size (배열)

*   기본: 합집합(union) + 중복 제거
*   정규화:
    *   색상: “오프화이트/오프화이트색/오프화이트 컬러” 같은 변형 통일
    *   사이즈: “S, Small, 90” 같은 혼재 → 운영 규칙으로 매핑(카테고리별로 다름)

* * *

### (F) description

*   가장 위험한 필드(마케팅 문구가 섞이기 쉬움)
*   추천 룰:
    1.  사실 정보 위주(소재/핏/기능/구성) 문장만 남김
    2.  중복 제거
    3.  최종 길이 제한(예: 200~300자)
    4.  여러 part의 description이 있으면 “합치고 자르기” (요약은 가급적 하지 말고 잘라내기 추천 — 요약은 상상 여지 생김)

* * *

3) 이미지 분할 최적화 (높이 제각각 + 어디 구간인지 모를 때)
-------------------------------------

### 목표

*   4096 토큰 제한을 넘지 않게
*   정보 누락(경계에 걸림) 최소화

### 추천 분할 규칙

*   **고정 높이 기준 + 겹침(overlap)** 이 가장 안정적

예시(실무에서 흔한 설정):

*   `chunk_height = 1400~1800px`
*   `overlap = 20~30%` (예: 300~500px)

왜 겹치냐?

*   상품명/소재표/고시정보가 경계에 걸리면 한쪽 chunk에서 깨질 수 있음.
*   겹침이 있으면 다른 chunk에서 온전하게 잡힐 확률이 커짐.

### 분할 개수 제한 팁

*   너무 많이 쪼개면 호출 비용 폭증
*   보통 3~6조각 안에서 끝내도록:
    *   아주 긴 이미지는 “우선 상단/중단/하단 3분할” + 필요시 추가 세분화 같은 하이브리드도 가능

* * *

4) 카테고리별 병합 전략 차별화 (정확도 크게 차이남)
-------------------------------

카테고리마다 “어떤 정보가 어디에 등장하는지” 패턴이 달라서, 병합 룰을 살짝 바꾸면 성능이 확 뛰어.

### 패션/잡화

*   상단: 상품명/브랜드
*   중단: 색상/사이즈/핏/소재
*   하단: 세탁/주의/교환/배송(노이즈 비율 높음)  
    **전략**
*   하단 chunk는 material/origin 추출에는 유효(고시정보), description엔 가중치 낮게

### 뷰티

*   성분/사용법/용량이 중요  
    **전략**
*   “전성분/사용방법/용량”은 하단에 몰려있을 수 있음 → 하단 chunk 가중치 올림
*   마케팅 문구 제거가 매우 중요

### 식품

*   영양성분/원재료/알레르겐/보관방법이 핵심  
    **전략**
*   표/고시 영역(보통 하단)에서 정보가 많이 나옴 → 하단 chunk 우선
*   “배송/교환” 노이즈와 고시정보가 섞여서 필터 규칙 강화 필요

### 가전/디지털

*   스펙표가 핵심, 표 OCR이 흔들림  
    **전략**
*   겹침(overlap) 더 크게(30% 권장)
*   description보다 “스펙성 텍스트”를 우선
*   가능하면 스키마를 “스펙 dict”로 확장하는 게 장기적으로 유리

* * *

5) 완전 자동화 파이프라인 설계도 (운영 플로우)
----------------------------

### Step 0. 입력 수신

*   원본 이미지 (높이/폭 다양, 어느 구간인지 모름)

### Step 1. 길이 판단 & 분할

*   `if height <= H_threshold` → 단일 호출
*   `else` → 규칙 기반 분할 + 겹침

### Step 2. 각 분할 이미지 → VL 호출 (부분 JSON)

*   프롬프트 핵심 문구(분할 이미지용):
    *   “이 이미지는 상세페이지의 일부일 수 있다”
    *   “보이는 텍스트만”
    *   “추측 금지”
    *   “확인 안 되면 null”
    *   “JSON만 출력”

### Step 3. 결과 검증

*   JSON 파싱 성공?
*   필수 필드가 너무 많이 null?
*   description이 너무 길거나 마케팅 문구 비율 높음?

→ 실패하면 “재시도 정책”:

*   프롬프트에 “작은 글씨/표 다시 확인” 추가해서 1회 재시도
*   그래도 실패하면 해당 part만 제외하거나 fallback(아래 Step 6)

### Step 4. 규칙 기반 병합 (코드)

*   field별 병합 + 충돌 해결
*   배열 합집합
*   brand/product\_name은 보수적으로

### Step 5. 최종 검증 & 정규화

*   색상/사이즈 표준화 룰 적용
*   국가명 통일(한국→대한민국 등)
*   description 길이 컷(200~300자)

### Step 6. Fallback (선택)

아주 어려운 케이스(표 깨짐/노이즈 폭탄)는:

*   **최종 병합 결과가 품질 기준 미달이면**
    *   “OCR 텍스트만 뽑는 모드”로 다시 시도(하지만 여전히 VL 1회 내에서)
    *   혹은 해당 카테고리 전용 프롬프트로 재시도

* * *

운영에서 꼭 넣으면 좋은 “품질 지표 3개”
------------------------

1.  `null_ratio` (필드 중 null 비율)
2.  `parse_fail_rate` (JSON 파싱 실패율)
3.  `conflict_rate` (brand/material/origin 충돌 빈도)

이 3개만 모니터링해도 “어디가 망가지고 있는지” 바로 보임.

* * *

원하면 다음으로는, 위 설계를 **바로 복붙해서 쓸 수 있게**:

*   ✅ “분할 이미지용 한글 프롬프트(초압축/4096 안전)”
*   ✅ “병합 규칙을 코드로 옮길 때 쓰는 필드별 룰 정의서”
*   ✅ “충돌 플래그 스키마(검증 필요 표시)”

까지 한 번에 템플릿 형태로 만들어줄게.

## Response:
좋아 👍  
그럼 바로 **실전에서 복붙해서 쓸 수 있는 형태**로 정리해줄게.

아래 3세트 제공할게:

1️⃣ 분할 이미지용 한글 프롬프트 (4096 안전 압축 버전)  
2️⃣ 병합 규칙 정의서 (코드로 옮기기 쉬운 형태)  
3️⃣ 충돌/검증 플래그 포함 최종 스키마 설계

* * *

1️⃣ 분할 이미지용 한글 프롬프트 (실전 압축 버전)
==============================

> ✔ 세로 긴 상세페이지를 분할해서 처리할 때 사용  
> ✔ 토큰 절약형  
> ✔ hallucination 최소화 문장 포함

```
당신은 전자상거래 상품 정보 추출 전문가다.

입력 이미지는 상품 상세페이지의 일부 구간일 수 있다.

[작업 절차]

1. 이미지에 보이는 모든 텍스트를 정확히 읽어라.
   - 보이는 텍스트만 사용하라.
   - 보이지 않는 정보는 추측하지 말라.
   - 로고 모양이나 디자인으로 브랜드를 추측하지 말라.

2. 다음 정보는 제거하라:
   - 고객센터 전화번호
   - 배송/교환/환불 안내
   - 할인/이벤트 문구
   - 카드사 혜택
   - 리뷰 이벤트
   - 감성적 마케팅 문구

3. 남은 정보 중 이 이미지 구간에서 확인 가능한 정보만
   아래 JSON 스키마에 맞게 작성하라.

[중요 규칙]
- 명확히 보이는 정보만 사용하라.
- 추측하지 말라.
- 확인되지 않으면 null로 설정하라.
- 반드시 JSON만 출력하라.

JSON 스키마:
{
  "product_name": 문자열 또는 null,
  "brand": 문자열 또는 null,
  "category": 문자열 또는 null,
  "material": 문자열 또는 null,
  "origin_country": 문자열 또는 null,
  "color": 문자열 배열 또는 null,
  "size": 문자열 배열 또는 null,
  "description": 200자 이내 문자열 또는 null
}
```

👉 이 버전은 약 350~500 토큰 내로 유지됨.

* * *

2️⃣ 병합 규칙 정의서 (코드 설계용)
======================

아래는 **LLM 없이 병합하는 기준 문서**야.

* * *

📌 공통 전처리 (모든 필드 적용)
--------------------

*   문자열 trim
*   공백 정리
*   중복 제거
*   “-”, “|”, “/” 통일
*   빈 문자열 → null 처리

* * *

📌 필드별 병합 규칙
------------

### 🔹 product\_name

1.  null 아닌 값 수집
2.  가장 긴 문자열 선택
3.  상단 part index 값 우선
4.  옵션명 포함 시 옵션 제거 (가능하면)

* * *

### 🔹 brand

1.  null 아닌 값 수집
2.  고유 값 1개 → 사용
3.  서로 다른 값 2개 이상 → null 처리
4.  충돌 시 conflict\_flag.brand = true

* * *

### 🔹 category

*   복수 존재 시 가장 상단 part 값 사용
*   확신 없으면 null

* * *

### 🔹 material

1.  null 아닌 값 수집
2.  더 구체적인 표현 선택
    *   “면” vs “면 100%” → “면 100%”
3.  서로 완전히 다른 값 2개 이상이면:
    *   둘 다 포함 가능하면 병합
    *   불가능하면 conflict\_flag.material = true

* * *

### 🔹 origin\_country

1.  국가명 정규화
    *   한국 → 대한민국
2.  값 다르면 conflict\_flag.origin = true

* * *

### 🔹 color

1.  모든 배열 합집합
2.  중복 제거
3.  표준화 (화이트/White → 화이트 등 정책에 따라)

* * *

### 🔹 size

1.  모든 배열 합집합
2.  중복 제거
3.  “S / Small / 90” 매핑 규칙이 있다면 적용

* * *

### 🔹 description

1.  null 아닌 값 수집
2.  중복 제거
3.  마케팅 문구 필터링
4.  300자 초과 시 자르기
5.  여러 개면 이어붙이되 줄바꿈 유지

* * *

3️⃣ 충돌 플래그 포함 최종 스키마
====================

운영 단계에서 굉장히 유용함.

* * *

✅ 최종 상품 JSON
------------

```json
{
  "product_name": "...",
  "brand": "...",
  "category": "...",
  "material": "...",
  "origin_country": "...",
  "color": [],
  "size": [],
  "description": "...",
  "meta": {
    "source_parts": 3,
    "conflict": {
      "brand": false,
      "material": false,
      "origin_country": false
    },
    "null_ratio": 0.25
  }
}
```

* * *

📌 meta 필드 설명
-------------

### 🔹 source\_parts

몇 개의 분할 이미지에서 정보가 추출되었는지

### 🔹 conflict

충돌 발생 여부

### 🔹 null\_ratio

null 필드 비율 (품질 평가용)

* * *

🔥 운영에서 이 구조의 장점
================

✔ 분할 이미지 대응 가능  
✔ 4096 토큰 안전  
✔ hallucination 최소화  
✔ 재현성 확보  
✔ 품질 모니터링 가능  
✔ 자동 검수 시스템 연결 가능

* * *

🎯 다음 단계로 가능한 것
===============

이제 진짜 고급 단계로 갈 수 있음:

1️⃣ 자동 품질 평가 점수 산출 로직 설계  
2️⃣ “재시도 조건” 자동 판단 알고리즘  
3️⃣ 카테고리별 분기 프롬프트 템플릿 제작  
4️⃣ 스펙표 중심 카테고리(가전/식품) 특화 설계  
5️⃣ 전체 파이프라인 다이어그램 + 운영 시나리오

어디까지 밀어볼까? 😎



---
Powered by [ChatGPT Exporter](https://www.chatgptexporter.com)